/*

 --- THE MAIN IDEA OF MY SOLUTION ---
First generate the first path, using any simple and fast algorithm.
Then generate the second path by dijkstra with penalty for each color visited by
the first path. Then generate the third path with penalties for colors on second
path, and so on.
After 973ms return the last two paths generated.

 --- Details/Optimizations ---
Classic dijksta is modificated this way: I don't penalize visiting colors that
have already been visited by path that is currently under construction.
For each vertex I store colors that have been passed through during path to the
vertex. In order to save memory and processor time I use persistent data
structure for color sets.
The first path is chosen from a few of candidates generated by various
algorithms: bfs, dfs, randomized bfs.

*/
#include <bits/stdc++.h>
using namespace std;
using namespace std::chrono;

// I need to know number of colors in order
// to use vector<bool> to store visited colors
int NUMBER_OF_COLORS;

// SHARED_COLOR_COST = 400 * n
int SHARED_COLOR_COST;

// Edges are represented using their weight and list of colors
typedef pair<uint16_t, vector<uint16_t>> GraphEdge;

// Graph is a map of pair of vectices (u,v) into edge e(u,v) between them.
// For efficiency it is represented by vector of maps, where
//   u - index of vector
//   v - key of map G[u]
// So G[u][v] = e(u,v)
typedef vector<map<int16_t, GraphEdge>> Graph;

// I store the graph in global variable because I am too lazy to implement
// the whole program in methods of the Graph type.
Graph G;

// I represent paths by vectors of their vertices in reverse order
typedef vector<int16_t> Path;

// I represent a query by (s, t) and best pair of paths currently found for it
typedef tuple<uint16_t, uint16_t, pair<Path, Path>> Query;
vector<Query> QUERIS;




/*
 --- Path cost calculation ---
Path cost calculation is done according to the statement of the problem.
1. Calculate colors of both paths and costs of their edges
2. Add edge costs and number of shared colors multiplied by SHARED_COLOR_COST
*/

// Calculate all colors visited by path and sum of weights of its edges
// The sum of weights is stored in edge_costs variable
vector<bool> get_colors_and_sum_of_edge_costs(Path &path, int *edge_costs) {
	// Colors are stored in a bit vector
	// colors[A] is true if and only if color A is visited by the path
	vector<bool> colors(NUMBER_OF_COLORS + 1);

	// I go over all the edges of the path and accumulate desired info
	int path_length = path.size();
	for (int i = 1; i < path_length; i++) {
		auto &[edge_cost, edge_colors] = G[path[i - 1]][path[i]];
		for (int risk : edge_colors)
			colors[risk] = true;
		*edge_costs += edge_cost;
	}
	return colors;
}

// Calculate Cost(S1, S2) according to the statement of the problem
int get_path_cost(pair<Path, Path> &paths) {
	int cost = 0;
	// cost = (sum of weights of path#1) + (sum of weights of path#2)
	auto colors1 = get_colors_and_sum_of_edge_costs(paths.first, &cost);
	auto colors2 = get_colors_and_sum_of_edge_costs(paths.second, &cost);

	// cost += 400 * n * Colors(S1, S2)
	for (int i = 0; i <= NUMBER_OF_COLORS; i++)
		if (colors1[i] && colors2[i])
			// SHARED_COLOR_COST = 400 * n
			cost += SHARED_COLOR_COST;

	return cost;
}

// Calculate all colors visited by path
vector<bool> get_colors(Path &path) {
	// Colors are stored in a bit vector
	// colors[A] is true if and only if color A is visited by the path
	vector<bool> colors(NUMBER_OF_COLORS + 1);

	// I go over all the edges of the path and accumulate their colors
	int path_length = path.size();
	for (int i = 1; i < path_length; i++)
		for (int risk : G[path[i - 1]][path[i]].second)
			colors[risk] = true;
	return colors;
}




/*
 --- Persistent data structure ---
In order to store visited colors I needed data structure with these properties:
1. Fast copying -- every vertex will have their own instance
2. Fast insertion of an element -- I gonna insert colors when passing edges

And I implemented such a structure according to this tutorial:
https://hypirion.com/musings/understanding-persistent-vector-pt-1

My implementation has these hardcoded properties:
 - Every inner node has four children.
 - Leaves store 16 binary values
 - The tree has depth 5
So total capacity of one instance is 16*4^5 = 16384 binary values.
Every bit represents some color: 1 means the color was visited, 0 -- otherwise.

P.S. according to problem statement there might be more than 16384 colors,
but that has not happen, so I'm lucky.
*/

// Every inner node has four children
typedef array<int, 4> SetNode;

// All nodes are stored in global variable and deleted at start of dijkstra
vector<SetNode> set_nodes;

// Every leaf stores 16 boolean values that define represent 16 colors
vector<uint16_t> bits;

// Search for color in a set with root node located at set_nodes[root]
bool set_contains(int root, int elem) {
	// Recursion was slow, so I have inlined all 5 recursive calls.
	int lvl0 = set_nodes[root][elem >> 12];
	int lvl1 = set_nodes[lvl0][(elem >> 10) & 3];
	int lvl2 = set_nodes[lvl1][(elem >> 8) & 3];
	int lvl3 = set_nodes[lvl2][(elem >> 6) & 3];
	int lvl4 = set_nodes[lvl3][(elem >> 4) & 3];
	return (bits[lvl4] >> (elem & 0xf)) & 1;
}

// Insert color into set of colors with root node located at set_nodes[root]
int set_insert(int root, int elem) {
	// Btw, I have more readable, recursive code if you ask
	SetNode lvl0 = set_nodes[root];
	SetNode lvl1 = set_nodes[lvl0[elem >> 12]];
	SetNode lvl2 = set_nodes[lvl1[(elem >> 10) & 3]];
	SetNode lvl3 = set_nodes[lvl2[(elem >> 8) & 3]];
	SetNode lvl4 = set_nodes[lvl3[(elem >> 6) & 3]];
	uint16_t lvl5 = bits[lvl4[(elem >> 4) & 3]];
	lvl5 |= 1 << (elem & 0xf); bits.push_back(lvl5);
	lvl4[(elem >> 4) & 3] = bits.size() - 1; set_nodes.push_back(lvl4);
	lvl3[(elem >> 6) & 3] = set_nodes.size() - 1; set_nodes.push_back(lvl3);
	lvl2[(elem >> 8) & 3] = set_nodes.size() - 1; set_nodes.push_back(lvl2);
	lvl1[(elem >> 10) & 3] = set_nodes.size() - 1; set_nodes.push_back(lvl1);
	lvl0[(elem >> 12) & 3] = set_nodes.size() - 1; set_nodes.push_back(lvl0);
	return set_nodes.size() - 1;
}




/*
 --- Dijkstra ---
This is classic dijksta with optimization:
do not penalize visiting a color if it has already been visited on the way to
the current vertex
*/

// Queue used in dijkstra contains pairs of vertices with smallest cost of
// getting into them. The algo pops the vertex with minimum cost out of queue at
// each iteration.
typedef pair<int, int16_t> QueueEntry;
struct queue_entity_comparator {
	bool operator() (const QueueEntry &left, const QueueEntry &right) {
		return left.first > right.first;
	}
};


// Behold the Dijkstra
Path dijkstra(int16_t s, int16_t t, vector<bool> other_path_colors) {
	int n = G.size();

	// Delete all color set nodes at each run in order to not waste memory
	bits = {0};
	set_nodes = {{}};

	// At start initialize all vertices to have very big minimal cost
	vector<int> min_cost(n, 0x7fffffff);

	// In order to restore path later we need to remember previous vertex 
	// for every vertex. I call a previous vertex a parent.
	vector<int16_t> parents(n);

	// The start vertex does not have a parent
	parents[s] = -1;

	// For every vertex I store colors that were visited it path to it
	vector<int> color_sets(n);

	// First step of dijkstra is to put start vertex into the queue
	priority_queue<QueueEntry, vector<QueueEntry>, queue_entity_comparator> queue;
	queue.push({0, s});

	// This while loop should be for loop, but it looked ugly, so it's not
	while (true) {
		// Pop the closest vertex out of the queue
		auto [current_cost, u] = queue.top();
		queue.pop();

		// Stop if we have reached the target vertex
		if (u == t) break;

		// If this vertex has already been visited by better path, skip it
		if (min_cost[u] < current_cost) continue;

		// Iterate over all the edges of current vertex and
		// add them into the queue if current path to them is
		// less costly than the previous one
		for (auto &[v, uv_edge] : G[u]) {
			if (min_cost[v] <= current_cost) continue;
			auto &[edge_cost, edge_colors] = uv_edge;
			int v_cost = current_cost + edge_cost;
			auto next_set = color_sets[u];
			for (auto color : edge_colors) {
				// Penalize only colors that have been visited by the other path
				if (!other_path_colors[color]) continue;

				// Ignore colors that have already been visited by this path
				if (set_contains(next_set, color)) continue;

				v_cost += SHARED_COLOR_COST;
				// Create new set of colors by inserting visited color into it
				next_set = set_insert(next_set, color);
			}
			if (min_cost[v] <= v_cost) continue;

			// Update information about next vertex and put it into the queue
			min_cost[v] = v_cost;
			parents[v] = u;
			color_sets[v] = next_set;
			queue.push({v_cost, v});
		}
	}

	// Build path by iteration over the parents vector
	// P.S. the path is builded in reverse order, i.e.
	//     path[0] = t, path[path_length] = s
	Path path = {t};
	while (t != s)
		path.push_back(t = parents[t]);
	return path;
}



/*
 --- First path generation. ---
It doesn't really matter how to generate the first path, but trying a few
slightly different candidates during runtime improves my score, so I have
implemented three algorithms: BFS, DFS and randomized BFS.
I generate a few candidates by them, generate a second path for each of the
candidates and take the best pair to the next stage.
*/

// Classic breadth-first search copypasted from wikipedia
Path bfs(int s, int t) {
	vector<int16_t> previous(G.size());
	queue<int16_t> Q;
	Q.push(s);
	previous[s] = -1;
	while (!previous[t]) {
		int16_t u = Q.front(); Q.pop();
		for (auto &[v, edge] : G[u]) {
			if (previous[v]) continue;
			previous[v] = u;
			Q.push(v);
		}
	}
	Path path;
	int u = t; path.push_back(u);
	while (previous[u] != -1) path.push_back(u = previous[u]);
	return path;
}

// Classic depth-first search copypasted from wikipedia
Path dfs(int s, int t) {
	vector<int16_t> previous(G.size());
	stack<int16_t> Q;
	Q.push(s);
	previous[s] = -1;
	while (!previous[t]) {
		int16_t u = Q.top(); Q.pop();
		for (auto &[v, edge] : G[u]) {
			if (previous[v]) continue;
			previous[v] = u;
			Q.push(v);
		}
	}
	Path path;
	int u = t; path.push_back(u);
	while (previous[u] != -1) path.push_back(u = previous[u]);
	return path;
}

// BFS with one modification to make it a little bit random
Path rfs3(int s, int t) {
	vector<int16_t> previous(G.size());
	queue<int16_t> Q;
	Q.push(s);
	previous[s] = -1;
	while (!previous[t]) {
		int16_t u = Q.front(); Q.pop();
		// There is 33% chance I don't process vertex and
		// just put it into the end of the queue
		if (rand() % 3 == 0) {
			Q.push(u);
			continue;
		}
		for (auto &[v, edge] : G[u]) {
			if (previous[v]) continue;
			previous[v] = u;
			Q.push(v);
		}
	}
	Path path;
	int u = t; path.push_back(u);
	while (previous[u] != -1) path.push_back(u = previous[u]);
	return path;
}

// Oh. It the same thing as above but with different level of randomization.
// Sorry for code duplication...
Path rfs4(int s, int t) {
	vector<int16_t> previous(G.size());
	queue<int16_t> Q;
	Q.push(s);
	previous[s] = -1;
	while (!previous[t]) {
		int16_t u = Q.front(); Q.pop();
		// 25% chance to process another vertex
		if (rand() % 4 == 0) {
			Q.push(u);
			continue;
		}
		for (auto &[v, edge] : G[u]) {
			if (previous[v]) continue;
			previous[v] = u;
			Q.push(v);
		}
	}
	Path path;
	int u = t; path.push_back(u);
	while (previous[u] != -1) path.push_back(u = previous[u]);
	return path;
}



// just a function to print path
void print_path(Path &path) {
	int n = path.size();
	cout << n - 1;
	for (int i = n - 1; i >= 0; i--)
		cout << " " << path[i];
	cout << endl;
}

int main() {
	// I need to track time in order to not exceed 1 sec limit
	auto the_start_time = high_resolution_clock::now();

	// Parse input
	int n, m, q;
	cin >> n >> m >> q;
	G.resize(n + 1);
	for (int i = 0; i < m; i++) {
		uint16_t u, v, w, k;
		cin >> u >> v >> w >> k;
		vector<uint16_t> C;
		for (int i = 0; i < k; i++) {
			uint16_t c;
			cin >> c;
			C.push_back(c);
		}
		G[u][v] = {w, C};
		G[v][u] = {w, C};
	}

	// Set some global variables before doing anything serious
	SHARED_COLOR_COST = n * 400;
	NUMBER_OF_COLORS = m;
	QUERIS.resize(q);
	srand(0x28fc927b); // chosen by thirteen fair dice rolls.
					   // guarateed to be random.

	// Estimate optimal number of candidates for first path.
	// The formula was obtained experimentally and works good for all tests
	// (except the first one)
	int max_number_of_candidates_for_first_path = 921666 / (q * m);

	for (int i = 0; i < q; i++) {
		uint16_t u, v;
		cin >> u >> v;

		// The first candidate is just BFS
		pair<Path, Path> best_paths;
		best_paths.first = bfs(u, v);
		best_paths.second = dijkstra(u, v, get_colors(best_paths.first));
		int min_cost = get_path_cost(best_paths);

		for (int i = 0; i < max_number_of_candidates_for_first_path; i++) {
			pair<Path, Path> paths;
			if (i == 0)
				// The second candidate is DFS
				paths.first = dfs(u, v);
			else
				// All other candidates are random paths
				paths.first = (i % 2 == 1) ? rfs3(u, v) : rfs4(u, v);

			// For every candidate a good partner is generated by the deikstra
			paths.second = dijkstra(u, v, get_colors(paths.first));

			// Update best candidate if current is bester
			int cost = get_path_cost(paths);
			if (cost < min_cost) {
				best_paths = paths;
				min_cost = cost;
			}
		}

		// Save the first pair of paths
		QUERIS[i] = {u, v, best_paths};
	}

	// Iteratively improve current solution for all queris
	for (int i = 0;; i++) {
		// If the time limit is close, stop at current solution
		auto dt = duration_cast<microseconds>(high_resolution_clock::now() - the_start_time);
		if (dt.count() > 973666) break;

		auto &[u, v, paths] = QUERIS[i % q];
		// In first q itearations I improve the first path using the second one.
		// In next q itearations I improve the second path using the first one.
		// In next q itearations I improve the first path using the second one.
		// And so on.
		if ((i % (2*q)) < q)
			paths.first = dijkstra(u, v, get_colors(paths.second));
		else
			paths.second = dijkstra(u, v, get_colors(paths.first));
	}

	// Output
	for (int i = 0; i < q; i++) {
		auto &[u, v, paths] = QUERIS[i];
		print_path(paths.first);
		print_path(paths.second);
	}
	return 0;
}
